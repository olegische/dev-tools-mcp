# Стратегия реализации отмены изменений (Rollback)

## Архитектура системы

```
Фронт → Модель Агент → MCP Инструменты (скрыты)
```

- **Фронт**: Пользовательский интерфейс, НЕТ прямой интеграции с инструментами
- **Модель Агент**: SWE агент, который выполняет пошаговые изменения файлов
- **MCP Инструменты**: Набор инструментов, включая GitTool для работы с git

## Сценарий использования

1. На фронте выставляются "tools ask user" 
2. SWE агент идет по шагам и меняет файлы
3. Когда все сделано, агент останавливается и спрашивает пользователя что делать дальше
4. **В этот момент** пользователь может запросить отмену всех изменений

## Решение: Git Restore через агента

### Существующая инфраструктура

В `GitTool` уже есть команда `restore`:
```python
case "restore":
    restore_path = arguments.get("restore_path", ".")
    cmd = f"{base_cmd} restore {restore_path}"
```

### Рекомендуемый поток

```
1. ФРОНТ: 
   Пользователь нажимает "Отменить изменения"

2. ФРОНТ → АГЕНТ: 
   {
     "action": "rollback_changes",
     "context": "user_requested_rollback"
   }

3. АГЕНТ выполняет последовательность:
   a) git_tool(command="status") - получить список измененных файлов
   b) git_tool(command="restore", restore_path=".") - откатить все изменения
   
4. АГЕНТ → ФРОНТ:
   {
     "status": "completed", 
     "message": "Отменено изменений в файлах: file1.py, file2.js",
     "restored_files": ["file1.py", "file2.js"]
   }
```

## Преимущества решения

✅ **Безопасность**: Использует git restore - надежный механизм отката  
✅ **Простота**: Использует существующую инфраструктуру  
✅ **Архитектурная совместимость**: Не нарушает принцип изоляции фронта от инструментов  
✅ **Логирование**: Все операции проходят через агента и логируются  
✅ **Контроль**: Агент может проверить состояние перед откатом  

## Варианты реализации

### 1. Базовый вариант (рекомендуемый)
Использовать существующие команды GitTool:
- `git_tool(command="status")` - для анализа изменений
- `git_tool(command="restore", restore_path=".")` - для отката

### 2. Расширенный вариант
Добавить в GitTool новую команду `rollback_all`:

```python
case "rollback_all":
    # Получаем список измененных файлов
    status_cmd = f"{base_cmd} status --porcelain"
    return_code, stdout, stderr = await run(status_cmd)
    
    if return_code == 0 and stdout.strip():
        # Есть изменения - откатываем их
        restore_cmd = f"{base_cmd} restore ."
        return_code, stdout, stderr = await run(restore_cmd)
        return ToolExecResult(
            output=f"Rolled back all changes. Files restored to last commit state.", 
            error=stderr, 
            error_code=return_code
        )
    else:
        return ToolExecResult(output="No changes to rollback.")
```

## Реализация в промпте агента

Добавить в системный промпт агента:

```markdown
### Обработка запросов на отмену изменений

Когда пользователь запрашивает отмену изменений:

1. **Анализ изменений**: 
   - Используй `git_tool` с `command="status"` для получения списка измененных файлов
   - Проинформируй пользователя о том, какие файлы будут затронуты

2. **Выполнение отката**:
   - Используй `git_tool` с `command="restore"` и `restore_path="."` для отката всех изменений
   - Альтернативно можно откатить конкретные файлы через `restore_path="specific_file.py"`

3. **Подтверждение**:
   - Сообщи пользователю о результате операции
   - Укажи какие файлы были восстановлены
```

## Альтернативные подходы (не рекомендуемые)

❌ **Прямая интеграция фронта с git**: Нарушает архитектуру  
❌ **Создание отдельного API**: Дублирование функциональности  
❌ **Использование bash_tool**: Менее безопасно и контролируемо  

## Заключение

Использование существующего GitTool через модель агента - это оптимальное решение, которое:
- Соответствует архитектурным принципам
- Использует проверенную инфраструктуру  
- Обеспечивает безопасность и контроль
- Минимизирует объем новой разработки

**Статус**: ✅ Готово к реализации  
**Сложность**: Низкая  
**Риски**: Минимальные  
