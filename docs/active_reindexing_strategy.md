# Стратегия активной переиндексации для CKG

Этот документ описывает продвинутую стратегию для поддержания Code Knowledge Graph (CKG) и векторной базы в актуальном состоянии. Подход основан на **активных триггерах** внутри инструментов, что устраняет необходимость во внешних наблюдателях за файлами (`File Watcher`) и делает систему более эффективной и надежной.

## 1. Ключевая идея: Реакция на события, а не пассивное наблюдение

Система построена на простом, но мощном принципе: поскольку **все изменения файловой системы проходят через инструменты MCP-сервера**, мы можем использовать эти вызовы как триггеры для переиндексации. Сервер точно знает, какой файл был изменен и в какой момент.

## 2. Центральный компонент: `IndexingService`

Чтобы управлять этим процессом, мы вводим новый центральный сервис.

-   **Назначение:** `IndexingService` — это синглтон или внедряемая зависимость, которая управляет состоянием CKG (SQLite) и векторной базы данных.
-   **API сервиса:**
    -   `async def on_file_changed(path: Path)`: Главный метод. Получает путь к измененному файлу, удаляет старые записи для этого файла из обеих баз данных и запускает для него конвейер переиндексации (парсинг, чанкинг, эмбеддинг, загрузка).
    -   `async def sync_from_git_diff(repo_path: Path, base_commit: str = None)`: Метод для "массовой" синхронизации в начале сессии.
-   **Внедрение:** Экземпляр `IndexingService` должен быть доступен всем инструментам, которые либо изменяют файлы, либо зависят от индекса.

## 3. Интеграция триггеров в инструменты

### `TextEditorTool` и `JSONEditTool`
Это наши главные источники изменений.
-   **Место вставки триггера:**
    -   В `TextEditorTool`: внутри метода `write_file()`.
    -   В `JSONEditTool`: внутри метода `_save_json_file()`.
-   **Реализация:** После успешной записи файла на диск, последней строкой в `try` блоке вызывается `await self._indexing_service.on_file_changed(path)`.
-   **Результат:** Любое изменение файла через эти инструменты мгновенно и автоматически обновляет индекс для этого конкретного файла.

### `GitTool` и первоначальная синхронизация
`GitTool` используется для приведения индекса в соответствие с текущим состоянием репозитория при старте задачи.
-   **Логика:** Метод `sync_from_git_diff` внутри `IndexingService` выполняет команду `git diff --name-only [base_commit] HEAD`.
-   **Действие:** Он получает список путей к файлам, которые были изменены, и для каждого файла в этом списке вызывает `await self.on_file_changed(path)`.
-   **Когда вызывать:** Этот метод должен вызываться один раз при инициализации сессии агента на стороне MCP-сервера, чтобы гарантировать, что индекс "знает" обо всех последних коммитах и локальных изменениях пользователя.

## 4. Решение проблемы "слепого пятна" (`bash_tool`)

Инструмент `bash` может изменять файлы (`echo "..." > file.txt`, `sed`, `mv`), и эти изменения мы отследить не можем.
-   **Решение:** Жесткое правило в системном промпте для облачного агента.
-   **Формулировка правила:**
    > **Критически важное правило:** Запрещено изменять, создавать или удалять файлы с помощью инструмента `bash`. Все модификации файловой системы должны производиться исключительно через инструменты `file_editor` и `json_editor`. Нарушение этого правила приведет к рассинхронизации индекса кода и, как следствие, к провалу задачи.

## 5. Итоговый рабочий процесс

1.  **Начало сессии:** Облачный агент начинает задачу. MCP-сервер вызывает `indexing_service.sync_from_git_diff()`. Индекс синхронизируется с текущим состоянием Git.
2.  **Анализ:** Агент использует `code_search` и `semantic_search`, которые обращаются к актуальному, "свежему" индексу.
3.  **Редактирование:** Агент решает изменить файл `src/api/auth.py` и вызывает `file_editor`.
4.  **Мгновенная переиндексация:** `file_editor` сохраняет изменения и немедленно вызывает `indexing_service.on_file_changed('.../src/api/auth.py')`. Сервис обновляет CKG и векторную базу только для этого файла.
5.  **Продолжение работы:** Следующий запрос агента к `code_search` уже будет работать с обновленными данными из `src/api/auth.py`.

Этот подход превращает систему индексации из медленной, пакетной операции в быструю, реактивную и хирургически точную систему, идеально подходящую для интерактивной работы с кодом.
